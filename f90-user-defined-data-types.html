<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NetCDF-Fortran: 5 User Defined Data Types</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="netcdf-50x50.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NetCDF-Fortran
   &#160;<span id="projectnumber">4.5.0-development</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('f90-user-defined-data-types.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">5 User Defined Data Types </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#f90-user-defined-types-introduction">5.1 User Defined Types Introduction </a></li>
<li class="level1"><a href="#f90-learn-the-ids-of-all-types-in-group-nf90_inq_typeids">5.2 Learn the IDs of All Types in Group: NF90_INQ_TYPEIDS </a></li>
<li class="level1"><a href="#f90-find-a-typeid-from-group-and-name-nf90_inq_typeid">5.3 Find a Typeid from Group and Name: nf90_inq_typeid </a></li>
<li class="level1"><a href="#f90-learn-about-a-user-defined-type-nf90_inq_type">5.4 Learn About a User Defined Type: NF90_INQ_TYPE </a></li>
<li class="level1"><a href="#f90-learn-about-a-user-defined-type-nf90_inq_user_type">5.5 Learn About a User Defined Type: NF90_INQ_USER_TYPE </a><ul><li class="level2"><a href="#f90-set-a-variable-length-array-with-nf90_put_vlen_element">5.5.1 Set a Variable Length Array with NF90_PUT_VLEN_ELEMENT</a></li>
<li class="level2"><a href="#f90-set-a-variable-length-array-with-nf90_get_vlen_element">5.5.2 Set a Variable Length Array with NF90_GET_VLEN_ELEMENT</a></li>
</ul>
</li>
<li class="level1"><a href="#f90-compound-types-introduction">5.6 Compound Types Introduction </a><ul><li class="level2"><a href="#f90-creating-a-compound-type-nf90_def_compound">5.6.1 Creating a Compound Type: NF90_DEF_COMPOUND</a></li>
<li class="level2"><a href="#f90-inserting-a-field-into-a-compound-type-nf90_insert_compound">5.6.2 Inserting a Field into a Compound Type: NF90_INSERT_COMPOUND</a></li>
<li class="level2"><a href="#f90-inserting-an-array-field-into-a-compound-type-nf90_insert_array_compound">5.6.3 Inserting an Array Field into a Compound Type: NF90_INSERT_ARRAY_COMPOUND</a></li>
<li class="level2"><a href="#f90-learn-about-a-compound-type-nf90_inq_compound">5.6.4 Learn About a Compound Type: NF90_INQ_COMPOUND</a></li>
<li class="level2"><a href="#f90-learn-about-a-field-of-a-compound-type-nf90_inq_compound_field">5.6.5 Learn About a Field of a Compound Type: NF90_INQ_COMPOUND_FIELD</a></li>
</ul>
</li>
<li class="level1"><a href="#f90-variable-length-array-introduction">5.7 Variable Length Array Introduction </a><ul><li class="level2"><a href="#f90-define-a-variable-length-array-vlen-nf90_def_vlen">5.7.1 Define a Variable Length Array (VLEN): NF90_DEF_VLEN</a></li>
<li class="level2"><a href="#f90-learning-about-a-variable-length-array-vlen-type-nf90_inq_vlen">5.7.2 Learning about a Variable Length Array (VLEN) Type: NF90_INQ_VLEN</a></li>
<li class="level2"><a href="#f90-releasing-memory-for-a-variable-length-array-vlen-type-nf90_free_vlen">5.7.3 Releasing Memory for a Variable Length Array (VLEN) Type: NF90_FREE_VLEN</a></li>
</ul>
</li>
<li class="level1"><a href="#f90-opaque-type-introduction">5.8 Opaque Type Introduction </a><ul><li class="level2"><a href="#f90-creating-opaque-types-nf90_def_opaque">5.8.1 Creating Opaque Types: NF90_DEF_OPAQUE</a></li>
<li class="level2"><a href="#f90-learn-about-an-opaque-type-nf90_inq_opaque">5.8.2 Learn About an Opaque Type: NF90_INQ_OPAQUE</a></li>
</ul>
</li>
<li class="level1"><a href="#f90-enum-type-introduction">5.9 Enum Type Introduction </a><ul><li class="level2"><a href="#f90-creating-a-enum-type-nf90_def_enum">5.9.1 Creating a Enum Type: NF90_DEF_ENUM</a></li>
<li class="level2"><a href="#f90-inserting-a-field-into-a-enum-type-nf90_insert_enum">5.9.2 Inserting a Field into a Enum Type: NF90_INSERT_ENUM</a></li>
<li class="level2"><a href="#f90-learn-about-a-enum-type-nf90_inq_enum">5.9.3 Learn About a Enum Type: NF90_INQ_ENUM</a></li>
<li class="level2"><a href="#f90-learn-the-name-of-a-enum-type-nf90_inq_enum_member">5.9.4 Learn the Name of a Enum Type: nf90_inq_enum_member</a></li>
<li class="level2"><a href="#f90-learn-the-name-of-a-enum-type-nf90_inq_enum_ident">5.9.5 Learn the Name of a Enum Type: NF90_INQ_ENUM_IDENT</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="f90-user-defined-types-introduction"></a>
5.1 User Defined Types Introduction </h1>
<p>NetCDF-4 has added support for four different user defined data types.</p>
<p><code>compound type</code></p>
<p>: Like a C struct, a compound type is a collection of types, including other user defined types, in one package.</p>
<p><code>variable length array type</code></p>
<p>: The variable length array may be used to store ragged arrays.</p>
<p><code>opaque type</code></p>
<p>: This type has only a size per element, and no other type information.</p>
<p><code>enum type</code></p>
<p>: Like an enumeration in C, this type lets you assign text values to integer values, and store the integer values.</p>
<p>Users may construct user defined type with the various NF90_DEF_* functions described in this section. They may learn about user defined types by using the NF90_INQ_ functions defined in this section.</p>
<p>Once types are constructed, define variables of the new type with NF90_DEF_VAR (see section <a href="#NF90_005fDEF_005fVAR">Create a Variable: <code>NF90_DEF_VAR</code></a>). Write to them with NF90_PUT_VAR (see section <a href="#NF90_005fPUT_005fVAR">Writing Data Values: <code>NF90_PUT_VAR</code></a>). Read data of user-defined type with NF90_GET_VAR (see section <a href="#NF90_005fGET_005fVAR">Reading Data Values: <code>NF90_GET_VAR</code></a>).</p>
<p>Create attributes of the new type with NF90_PUT_ATT (see section <a href="#NF90_005fPUT_005fATT">Create an Attribute: NF90_PUT_ATT</a>). Read attributes of the new type with NF90_GET_ATT (see section <a href="#NF90_005fGET_005fATT">Get Attribute’s Values: NF90_GET_ATT</a>).</p>
<h1><a class="anchor" id="f90-learn-the-ids-of-all-types-in-group-nf90_inq_typeids"></a>
5.2 Learn the IDs of All Types in Group: NF90_INQ_TYPEIDS </h1>
<p>Learn the number of types defined in a group, and their IDs.</p>
<h2>Usage</h2>
<div class="fragment"><div class="line"><span class="keyword">function </span>nf90_inq_typeids(ncid, ntypes, typeids)</div><div class="line">  <span class="keywordtype">integer</span>, <span class="keywordtype">intent(in)</span> :: ncid</div><div class="line">  <span class="keywordtype">integer</span>, <span class="keywordtype">intent(out)</span> :: ntypes</div><div class="line">  <span class="keywordtype">integer</span>, <span class="keywordtype">intent(out)</span> :: typeids</div><div class="line">  <span class="keywordtype">integer</span> :: nf90_inq_typeids</div></div><!-- fragment --><p><code>NCID</code></p>
<p>: The group id.</p>
<p><code>NTYPES</code></p>
<p>: A pointer to int which will get the number of types defined in the group. If NULL, ignored.</p>
<p><code>TYPEIDS</code></p>
<p>: A pointer to an int array which will get the typeids. If NULL, ignored.</p>
<h2>Errors</h2>
<p><code>NF90_NOERR</code></p>
<p>: No error.</p>
<p><code>NF90_BADID</code></p>
<p>: Bad ncid.</p>
<h2>Example</h2>
<h1><a class="anchor" id="f90-find-a-typeid-from-group-and-name-nf90_inq_typeid"></a>
5.3 Find a Typeid from Group and Name: nf90_inq_typeid </h1>
<p>Given a group ID and a type name, find the ID of the type. If the type is not found in the group, then the parents are searched. If still not found, the entire file is searched.</p>
<h2>Usage</h2>
<div class="fragment"><div class="line">int nf90_inq_typeid(int ncid, char *name, nf90_type *typeidp);</div></div><!-- fragment --><p><code>ncid</code></p>
<p>: The group id.</p>
<p><code>name</code></p>
<p>: The name of a type.</p>
<p><code>typeidp</code></p>
<p>: The typeid, if found.</p>
<h3>Errors</h3>
<p><code>NF90_NOERR</code></p>
<p>: No error.</p>
<p><code>NF90_EBADID</code></p>
<p>: Bad ncid.</p>
<p><code>NF90_EBADTYPE</code></p>
<p>: Can’t find type.</p>
<h2>Example</h2>
<h1><a class="anchor" id="f90-learn-about-a-user-defined-type-nf90_inq_type"></a>
5.4 Learn About a User Defined Type: NF90_INQ_TYPE </h1>
<p>Given an ncid and a typeid, get the information about a type. This function will work on any type, including atomic and any user defined type, whether compound, opaque, enumeration, or variable length array.</p>
<p>For even more information about a user defined type <a href="#NF90_005fINQ_005fUSER_005fTYPE">Learn About a User Defined Type: NF90_INQ_USER_TYPE</a>.</p>
<h2>Usage</h2>
<div class="fragment"><div class="line"><span class="keyword">function </span>nf90_inq_type(ncid, xtype, name, size)</div><div class="line">  <span class="keywordtype">integer</span>, <span class="keywordtype">intent(in)</span> :: ncid</div><div class="line">  <span class="keywordtype">integer</span>, <span class="keywordtype">intent(in)</span> :: xtype</div><div class="line">  <span class="keywordtype">character (len = *)</span>, <span class="keywordtype">intent(out)</span> :: name</div><div class="line">  <span class="keywordtype">integer</span>, <span class="keywordtype">intent(out)</span> :: size</div><div class="line">  <span class="keywordtype">integer</span> :: nf90_inq_type</div></div><!-- fragment --><p><code>NCID</code></p>
<p>: The ncid for the group containing the type (ignored for atomic types).</p>
<p><code>XTYPE</code></p>
<p>: The typeid for this type, as returned by NF90_DEF_COMPOUND, NF90_DEF_OPAQUE, NF90_DEF_ENUM, NF90_DEF_VLEN, or NF90_INQ_VAR, or as found in netcdf.inc in the list of atomic types (NF90_CHAR, NF90_INT, etc.).</p>
<p><code>NAME</code></p>
<p>: The name of the user defined type will be copied here. It will be NF90_MAX_NAME bytes or less. For atomic types, the type name from CDL will be given.</p>
<p><code>SIZEP</code></p>
<p>: The (in-memory) size of the type (in bytes) will be copied here. VLEN type size is the size of one element of the VLEN. String size is returned as the size of one char.</p>
<h2>Return Codes</h2>
<p><code>NF90_NOERR</code></p>
<p>: No error.</p>
<p><code>NF90_EBADTYPEID</code></p>
<p>: Bad typeid.</p>
<p><code>NF90_ENOTNC4</code></p>
<p>: Seeking a user-defined type in a netCDF-3 file.</p>
<p><code>NF90_ESTRICTNC3</code></p>
<p>: Seeking a user-defined type in a netCDF-4 file for which classic model has been turned on.</p>
<p><code>NF90_EBADGRPID</code></p>
<p>: Bad group ID in ncid.</p>
<p><code>NF90_EBADID</code></p>
<p>: Type ID not found.</p>
<p><code>NF90_EHDFERR</code></p>
<p>: An error was reported by the HDF5 layer.</p>
<h2>Example</h2>
<h1><a class="anchor" id="f90-learn-about-a-user-defined-type-nf90_inq_user_type"></a>
5.5 Learn About a User Defined Type: NF90_INQ_USER_TYPE </h1>
<p>Given an ncid and a typeid, get the information about a user defined type. This function will work on any user defined type, whether compound, opaque, enumeration, or variable length array.</p>
<h2>Usage</h2>
<div class="fragment"><div class="line"><span class="keyword">function </span>nf90_inq_user_type(ncid, xtype, name, size, base_typeid, nfields, class)</div><div class="line">  <span class="keywordtype">integer</span>, <span class="keywordtype">intent(in)</span> :: ncid</div><div class="line">  <span class="keywordtype">integer</span>, <span class="keywordtype">intent(in)</span> :: xtype</div><div class="line">  <span class="keywordtype">character (len = *)</span>, <span class="keywordtype">intent(out)</span> :: name</div><div class="line">  <span class="keywordtype">integer</span>, <span class="keywordtype">intent(out)</span> :: size</div><div class="line">  <span class="keywordtype">integer</span>, <span class="keywordtype">intent(out)</span> :: base_typeid</div><div class="line">  <span class="keywordtype">integer</span>, <span class="keywordtype">intent(out)</span> :: nfields</div><div class="line">  <span class="keywordtype">integer</span>, <span class="keywordtype">intent(out)</span> :: class</div><div class="line">  <span class="keywordtype">integer</span> :: nf90_inq_user_type</div></div><!-- fragment --><p><code>NCID</code></p>
<p>: The ncid for the group containing the user defined type.</p>
<p><code>XTYPE</code></p>
<p>: The typeid for this type, as returned by NF90_DEF_COMPOUND, NF90_DEF_OPAQUE, NF90_DEF_ENUM, NF90_DEF_VLEN, or NF90_INQ_VAR.</p>
<p><code>NAME</code></p>
<p>: The name of the user defined type will be copied here. It will be NF90_MAX_NAME bytes or less.</p>
<p><code>SIZE</code></p>
<p>: The (in-memory) size of the user defined type will be copied here.</p>
<p><code>BASE_NF90_TYPE</code></p>
<p>: The base typeid will be copied here for vlen and enum types.</p>
<p><code>NFIELDS</code></p>
<p>: The number of fields will be copied here for enum and compound types.</p>
<p><code>CLASS</code></p>
<p>: The class of the user defined type, NF90_VLEN, NF90_OPAQUE, NF90_ENUM, or NF90_COMPOUND, will be copied here.</p>
<h2>Errors</h2>
<p><code>NF90_NOERR</code></p>
<p>: No error.</p>
<p><code>NF90_EBADTYPEID</code></p>
<p>: Bad typeid.</p>
<p><code>NF90_EBADFIELDID</code></p>
<p>: Bad fieldid.</p>
<p><code>NF90_EHDFERR</code></p>
<p>: An error was reported by the HDF5 layer.</p>
<h2>Example</h2>
<h2><a class="anchor" id="f90-set-a-variable-length-array-with-nf90_put_vlen_element"></a>
5.5.1 Set a Variable Length Array with NF90_PUT_VLEN_ELEMENT</h2>
<p>Use this to set the element of the (potentially) n-dimensional array of VLEN. That is, this sets the data in one variable length array.</p>
<h3>Usage</h3>
<div class="fragment"><div class="line"><span class="keyword">INTEGER </span><span class="keyword">FUNCTION </span>nf90_put_vlen_element(INTEGER NCID, INTEGER XTYPE,</div><div class="line">        CHARACTER*(*) vlen_element, integer len, data)</div></div><!-- fragment --><p><code>NCID</code></p>
<p>: The ncid of the file that contains the VLEN type.</p>
<p><code>XTYPE</code></p>
<p>: The type of the VLEN.</p>
<p><code>VLEN_ELEMENT</code></p>
<p>: The VLEN element to be set.</p>
<p><code>LEN</code></p>
<p>: The number of entries in this array.</p>
<p><code>DATA</code></p>
<p>: The data to be stored. Must match the base type of this VLEN.</p>
<h3>Errors</h3>
<p><code>NF90_NOERR</code></p>
<p>: No error.</p>
<p><code>NF90_EBADTYPE</code></p>
<p>: Can’t find the typeid.</p>
<p><code>NF90_EBADID</code></p>
<p>: ncid invalid.</p>
<p><code>NF90_EBADGRPID</code></p>
<p>: Group ID part of ncid was invalid.</p>
<h3>Example</h3>
<p>This example is from nf90_test/ftst_vars4.F.</p>
<div class="fragment"><div class="line"><span class="comment">C     Set up the vlen with this helper function, since F90 can&#39;t deal</span></div><div class="line"><span class="comment">C     with pointers.</span></div><div class="line">      retval = nf90_put_vlen_element(ncid, vlen_typeid, vlen,</div><div class="line">     &amp;     vlen_len, data1)</div><div class="line">      <span class="keywordflow">if</span> (retval .ne. nf90_noerr) <span class="keyword">call </span>handle_err(retval)</div></div><!-- fragment --><h2><a class="anchor" id="f90-set-a-variable-length-array-with-nf90_get_vlen_element"></a>
5.5.2 Set a Variable Length Array with NF90_GET_VLEN_ELEMENT</h2>
<p>Use this to set the element of the (potentially) n-dimensional array of VLEN. That is, this sets the data in one variable length array.</p>
<h3>Usage</h3>
<div class="fragment"><div class="line"><span class="keyword">INTEGER </span><span class="keyword">FUNCTION </span>nf90_get_vlen_element(INTEGER NCID, INTEGER XTYPE,</div><div class="line">        CHARACTER*(*) vlen_element, integer len, data)</div></div><!-- fragment --><p><code>NCID</code></p>
<p>: The ncid of the file that contains the VLEN type.</p>
<p><code>XTYPE</code></p>
<p>: The type of the VLEN.</p>
<p><code>VLEN_ELEMENT</code></p>
<p>: The VLEN element to be set.</p>
<p><code>LEN</code></p>
<p>: This will be set to the number of entries in this array.</p>
<p><code>DATA</code></p>
<p>: The data will be copied here. Sufficient storage must be available or bad things will happen to you.</p>
<h3>Errors</h3>
<p><code>NF90_NOERR</code></p>
<p>: No error.</p>
<p><code>NF90_EBADTYPE</code></p>
<p>: Can’t find the typeid.</p>
<p><code>NF90_EBADID</code></p>
<p>: ncid invalid.</p>
<p><code>NF90_EBADGRPID</code></p>
<p>: Group ID part of ncid was invalid.</p>
<h3>Example</h3>
<h1><a class="anchor" id="f90-compound-types-introduction"></a>
5.6 Compound Types Introduction </h1>
<p>NetCDF-4 added support for compound types, which allow users to construct a new type - a combination of other types, like a C struct.</p>
<p>Compound types are not supported in classic or 64-bit offset format files.</p>
<p>To write data in a compound type, first use nf90_def_compound to create the type, multiple calls to nf90_insert_compound to add to the compound type, and then write data with the appropriate nf90_put_var1, nf90_put_vara, nf90_put_vars, or nf90_put_varm call.</p>
<p>To read data written in a compound type, you must know its structure. Use the NF90_INQ_COMPOUND functions to learn about the compound type.</p>
<p>In Fortran a character buffer must be used for the compound data. The user must read the data from within that buffer in the same way that the C compiler which compiled netCDF would store the structure.</p>
<p>The use of compound types introduces challenges and portability issues for Fortran users.</p>
<h2><a class="anchor" id="f90-creating-a-compound-type-nf90_def_compound"></a>
5.6.1 Creating a Compound Type: NF90_DEF_COMPOUND</h2>
<p>Create a compound type. Provide an ncid, a name, and a total size (in bytes) of one element of the completed compound type.</p>
<p>After calling this function, fill out the type with repeated calls to NF90_INSERT_COMPOUND (see section <a href="#NF90_005fINSERT_005fCOMPOUND">Inserting a Field into a Compound Type: NF90_INSERT_COMPOUND</a>). Call NF90_INSERT_COMPOUND once for each field you wish to insert into the compound type.</p>
<p>Note that there does not seem to be a fully portable way to read such types into structures in Fortran 90 (and there are no structures in Fortran 77). Dozens of top-notch programmers are swarming over this problem in a sub-basement of Unidata’s giant underground bunker in Wyoming.</p>
<p>Fortran users may use character buffers to read and write compound types. User are invited to try classic Fortran features such as the equivilence and the common block statment.</p>
<h3>Usage</h3>
<div class="fragment"><div class="line"><span class="keyword">function </span>nf90_def_compound(ncid, size, name, typeid)</div><div class="line">  <span class="keywordtype">integer</span>, <span class="keywordtype">intent(in)</span> :: ncid</div><div class="line">  <span class="keywordtype">integer</span>, <span class="keywordtype">intent(in)</span> :: size</div><div class="line">  <span class="keywordtype">character (len = *)</span>, <span class="keywordtype">intent(in)</span> :: name</div><div class="line">  <span class="keywordtype">integer</span>, <span class="keywordtype">intent(out)</span> :: typeid</div><div class="line">  <span class="keywordtype">integer</span> :: nf90_def_compound</div></div><!-- fragment --><p><code>NCID</code></p>
<p>: The groupid where this compound type will be created.</p>
<p><code>SIZE</code></p>
<p>: The size, in bytes, of the compound type.</p>
<p><code>NAME</code></p>
<p>: The name of the new compound type.</p>
<p><code>TYPEIDP</code></p>
<p>: The typeid of the new type will be placed here.</p>
<h3>Errors</h3>
<p><code>NF90_NOERR</code></p>
<p>: No error.</p>
<p><code>NF90_EBADID</code></p>
<p>: Bad group id.</p>
<p><code>NF90_ENAMEINUSE</code></p>
<p>: That name is in use. Compound type names must be unique in the data file.</p>
<p><code>NF90_EMAXNAME</code></p>
<p>: Name exceeds max length NF90_MAX_NAME.</p>
<p><code>NF90_EBADNAME</code></p>
<p>: Name contains illegal characters.</p>
<p><code>NF90_ENOTNC4</code></p>
<p>: Attempting a netCDF-4 operation on a netCDF-3 file. NetCDF-4 operations can only be performed on files defined with a create mode which includes flag NF90_NETCDF4. (see section <a href="#NF90_005fOPEN">NF90_OPEN</a>).</p>
<p><code>NF90_ESTRICTNC3</code></p>
<p>: This file was created with the strict netcdf-3 flag, therefore netcdf-4 operations are not allowed. (see section <a href="#NF90_005fOPEN">NF90_OPEN</a>).</p>
<p><code>NF90_EHDFERR</code></p>
<p>: An error was reported by the HDF5 layer.</p>
<p><code>NF90_EPERM</code></p>
<p>: Attempt to write to a read-only file.</p>
<p><code>NF90_ENOTINDEFINE</code></p>
<p>: Not in define mode.</p>
<h3>Example</h3>
<h2><a class="anchor" id="f90-inserting-a-field-into-a-compound-type-nf90_insert_compound"></a>
5.6.2 Inserting a Field into a Compound Type: NF90_INSERT_COMPOUND</h2>
<p>Insert a named field into a compound type.</p>
<h3>Usage</h3>
<div class="fragment"><div class="line"><span class="keyword">function </span>nf90_insert_compound(ncid, xtype, name, offset, field_typeid)</div><div class="line">  <span class="keywordtype">integer</span>, <span class="keywordtype">intent(in)</span> :: ncid</div><div class="line">  <span class="keywordtype">integer</span>, <span class="keywordtype">intent(in)</span> :: xtype</div><div class="line">  <span class="keywordtype">character (len = *)</span>, <span class="keywordtype">intent(in)</span> :: name</div><div class="line">  <span class="keywordtype">integer</span>, <span class="keywordtype">intent(in)</span> :: offset</div><div class="line">  <span class="keywordtype">integer</span>, <span class="keywordtype">intent(in)</span> :: field_typeid</div><div class="line">  <span class="keywordtype">integer</span> :: nf90_insert_compound</div></div><!-- fragment --><p><code>TYPEID</code></p>
<p>: The typeid for this compound type, as returned by NF90_DEF_COMPOUND, or NF90_INQ_VAR.</p>
<p><code>NAME</code></p>
<p>: The name of the new field.</p>
<p><code>OFFSET</code></p>
<p>: Offset in byte from the beginning of the compound type for this field.</p>
<p><code>FIELD_TYPEID</code></p>
<p>: The type of the field to be inserted.</p>
<h3>Errors</h3>
<p><code>NF90_NOERR</code></p>
<p>: No error.</p>
<p><code>NF90_EBADID</code></p>
<p>: Bad group id.</p>
<p><code>NF90_ENAMEINUSE</code></p>
<p>: That name is in use. Field names must be unique within a compound type.</p>
<p><code>NF90_EMAXNAME</code></p>
<p>: Name exceed max length NF90_MAX_NAME.</p>
<p><code>NF90_EBADNAME</code></p>
<p>: Name contains illegal characters.</p>
<p><code>NF90_ENOTNC4</code></p>
<p>: Attempting a netCDF-4 operation on a netCDF-3 file. NetCDF-4 operations can only be performed on files defined with a create mode which includes flag NF90_NETCDF4. (see section <a href="#NF90_005fOPEN">NF90_OPEN</a>).</p>
<p><code>NF90_ESTRICTNC3</code></p>
<p>: This file was created with the strict netcdf-3 flag, therefore netcdf-4 operations are not allowed. (see section <a href="#NF90_005fOPEN">NF90_OPEN</a>).</p>
<p><code>NF90_EHDFERR</code></p>
<p>: An error was reported by the HDF5 layer.</p>
<p><code>NF90_ENOTINDEFINE</code></p>
<p>: Not in define mode.</p>
<h3>Example</h3>
<h2><a class="anchor" id="f90-inserting-an-array-field-into-a-compound-type-nf90_insert_array_compound"></a>
5.6.3 Inserting an Array Field into a Compound Type: NF90_INSERT_ARRAY_COMPOUND</h2>
<p>Insert a named array field into a compound type.</p>
<h3>Usage</h3>
<div class="fragment"><div class="line"><span class="keyword">function </span>nf90_insert_array_compound(ncid, xtype, name, offset, field_typeid, &amp;</div><div class="line">     ndims, dim_sizes)</div><div class="line">  <span class="keywordtype">integer</span>, <span class="keywordtype">intent(in)</span> :: ncid</div><div class="line">  <span class="keywordtype">integer</span>, <span class="keywordtype">intent(in)</span> :: xtype</div><div class="line">  <span class="keywordtype">character (len = *)</span>, <span class="keywordtype">intent(in)</span> :: name</div><div class="line">  <span class="keywordtype">integer</span>, <span class="keywordtype">intent(in)</span> :: offset</div><div class="line">  <span class="keywordtype">integer</span>, <span class="keywordtype">intent(in)</span> :: field_typeid</div><div class="line">  <span class="keywordtype">integer</span>, <span class="keywordtype">intent(in)</span> :: ndims</div><div class="line">  <span class="keywordtype">integer</span>, <span class="keywordtype">intent(in)</span> :: dim_sizes</div><div class="line">  <span class="keywordtype">integer</span> :: nf90_insert_array_compound</div></div><!-- fragment --><p><code>NCID</code></p>
<p>: The ID of the file that contains the array type and the compound type.</p>
<p><code>XTYPE</code></p>
<p>: The typeid for this compound type, as returned by nf90_def_compound, or nf90_inq_var.</p>
<p><code>NAME</code></p>
<p>: The name of the new field.</p>
<p><code>OFFSET</code></p>
<p>: Offset in byte from the beginning of the compound type for this field.</p>
<p><code>FIELD_TYPEID</code></p>
<p>: The base type of the array to be inserted.</p>
<p><code>NDIMS</code></p>
<p>: The number of dimensions for the array to be inserted.</p>
<p><code>DIM_SIZES</code></p>
<p>: An array containing the sizes of each dimension.</p>
<h3>Errors</h3>
<p><code>NF90_NOERR</code></p>
<p>: No error.</p>
<p><code>NF90_EBADID</code></p>
<p>: Bad group id.</p>
<p><code>NF90_ENAMEINUSE</code></p>
<p>: That name is in use. Field names must be unique within a compound type.</p>
<p><code>NF90_EMAXNAME</code></p>
<p>: Name exceed max length NF90_MAX_NAME.</p>
<p><code>NF90_EBADNAME</code></p>
<p>: Name contains illegal characters.</p>
<p><code>NF90_ENOTNC4</code></p>
<p>: Attempting a netCDF-4 operation on a netCDF-3 file. NetCDF-4 operations can only be performed on files defined with a create mode which includes flag NF90_NETCDF4. (see section <a href="#NF90_005fOPEN">NF90_OPEN</a>).</p>
<p><code>NF90_ESTRICTNC3</code></p>
<p>: This file was created with the strict netcdf-3 flag, therefore netcdf-4 operations are not allowed. (see section <a href="#NF90_005fOPEN">NF90_OPEN</a>).</p>
<p><code>NF90_EHDFERR</code></p>
<p>: An error was reported by the HDF5 layer.</p>
<p><code>NF90_ENOTINDEFINE</code></p>
<p>: Not in define mode.</p>
<p><code>NF90_ETYPEDEFINED</code></p>
<p>: Attempt to change type that has already been committed. The first time the file leaves define mode, all defined types are committed, and can’t be changed. If you wish to add an array to a compound type, you must do so before the compound type is committed.</p>
<h3>Example</h3>
<h2><a class="anchor" id="f90-learn-about-a-compound-type-nf90_inq_compound"></a>
5.6.4 Learn About a Compound Type: NF90_INQ_COMPOUND</h2>
<p>Get the number of fields, length in bytes, and name of a compound type.</p>
<p>In addtion to the NF90_INQ_COMPOUND function, three additional functions are provided which get only the name, size, and number of fields.</p>
<h3>Usage</h3>
<div class="fragment"><div class="line"><span class="keyword">function </span>nf90_inq_compound(ncid, xtype, name, size, nfields)</div><div class="line">  <span class="keywordtype">integer</span>, <span class="keywordtype">intent(in)</span> :: ncid</div><div class="line">  <span class="keywordtype">integer</span>, <span class="keywordtype">intent(in)</span> :: xtype</div><div class="line">  <span class="keywordtype">character (len = *)</span>, <span class="keywordtype">intent(out)</span> :: name</div><div class="line">  <span class="keywordtype">integer</span>, <span class="keywordtype">intent(out)</span> :: size</div><div class="line">  <span class="keywordtype">integer</span>, <span class="keywordtype">intent(out)</span> :: nfields</div><div class="line">  <span class="keywordtype">integer</span> :: nf90_inq_compound</div><div class="line"></div><div class="line"><span class="keyword">function </span>nf90_inq_compound_name(ncid, xtype, name)</div><div class="line">  <span class="keywordtype">integer</span>, <span class="keywordtype">intent(in)</span> :: ncid</div><div class="line">  <span class="keywordtype">integer</span>, <span class="keywordtype">intent(in)</span> :: xtype</div><div class="line">  <span class="keywordtype">character (len = *)</span>, <span class="keywordtype">intent(out)</span> :: name</div><div class="line">  <span class="keywordtype">integer</span> :: nf90_inq_compound_name</div><div class="line"></div><div class="line"><span class="keyword">function </span>nf90_inq_compound_size(ncid, xtype, size)</div><div class="line">  <span class="keywordtype">integer</span>, <span class="keywordtype">intent(in)</span> :: ncid</div><div class="line">  <span class="keywordtype">integer</span>, <span class="keywordtype">intent(in)</span> :: xtype</div><div class="line">  <span class="keywordtype">integer</span>, <span class="keywordtype">intent(out)</span> :: size</div><div class="line">  <span class="keywordtype">integer</span> :: nf90_inq_compound_size</div><div class="line"></div><div class="line"><span class="keyword">function </span>nf90_inq_compound_nfields(ncid, xtype, nfields)</div><div class="line">  <span class="keywordtype">integer</span>, <span class="keywordtype">intent(in)</span> :: ncid</div><div class="line">  <span class="keywordtype">integer</span>, <span class="keywordtype">intent(in)</span> :: xtype</div><div class="line">  <span class="keywordtype">integer</span>, <span class="keywordtype">intent(out)</span> :: nfields</div><div class="line">  <span class="keywordtype">integer</span> :: nf90_inq_compound_nfields</div></div><!-- fragment --><p><code>NCID</code></p>
<p>: The ID of any group in the file that contains the compound type.</p>
<p><code>XTYPE</code></p>
<p>: The typeid for this compound type, as returned by NF90_DEF_COMPOUND, or NF90_INQ_VAR.</p>
<p><code>NAME</code></p>
<p>: Character array which will get the name of the compound type. It will have a maximum length of NF90_MAX_NAME.</p>
<p><code>SIZEP</code></p>
<p>: The size of the compound type in bytes will be put here.</p>
<p><code>NFIELDSP</code></p>
<p>: The number of fields in the compound type will be placed here.</p>
<h3>Return Codes</h3>
<p><code>NF90_NOERR</code></p>
<p>: No error.</p>
<p><code>NF90_EBADID</code></p>
<p>: Couldn’t find this ncid.</p>
<p><code>NF90_ENOTNC4</code></p>
<p>: Not a netCDF-4/HDF5 file.</p>
<p><code>NF90_ESTRICTNC3</code></p>
<p>: A netCDF-4/HDF5 file, but with CLASSIC_MODEL. No user defined types are allowed in the classic model.</p>
<p><code>NF90_EBADTYPE</code></p>
<p>: This type not a compound type.</p>
<p><code>NF90_EBADTYPEID</code></p>
<p>: Bad type id.</p>
<p><code>NF90_EHDFERR</code></p>
<p>: An error was reported by the HDF5 layer.</p>
<h3>Example</h3>
<h2><a class="anchor" id="f90-learn-about-a-field-of-a-compound-type-nf90_inq_compound_field"></a>
5.6.5 Learn About a Field of a Compound Type: NF90_INQ_COMPOUND_FIELD</h2>
<p>Get information about one of the fields of a compound type.</p>
<h3>Usage</h3>
<div class="fragment"><div class="line"><span class="keyword">function </span>nf90_inq_compound_field(ncid, xtype, fieldid, name, offset, &amp;</div><div class="line">     field_typeid, ndims, dim_sizes)</div><div class="line">  <span class="keywordtype">integer</span>, <span class="keywordtype">intent(in)</span> :: ncid</div><div class="line">  <span class="keywordtype">integer</span>, <span class="keywordtype">intent(in)</span> :: xtype</div><div class="line">  <span class="keywordtype">integer</span>, <span class="keywordtype">intent(in)</span> :: fieldid</div><div class="line">  <span class="keywordtype">character (len = *)</span>, <span class="keywordtype">intent(out)</span> :: name</div><div class="line">  <span class="keywordtype">integer</span>, <span class="keywordtype">intent(out)</span> :: offset</div><div class="line">  <span class="keywordtype">integer</span>, <span class="keywordtype">intent(out)</span> :: field_typeid</div><div class="line">  <span class="keywordtype">integer</span>, <span class="keywordtype">intent(out)</span> :: ndims</div><div class="line">  <span class="keywordtype">integer</span>, <span class="keywordtype">intent(out)</span> :: dim_sizes</div><div class="line">  <span class="keywordtype">integer</span> :: nf90_inq_compound_field</div><div class="line"></div><div class="line"><span class="keyword">function </span>nf90_inq_compound_fieldname(ncid, xtype, fieldid, name)</div><div class="line">  <span class="keywordtype">integer</span>, <span class="keywordtype">intent(in)</span> :: ncid</div><div class="line">  <span class="keywordtype">integer</span>, <span class="keywordtype">intent(in)</span> :: xtype</div><div class="line">  <span class="keywordtype">integer</span>, <span class="keywordtype">intent(in)</span> :: fieldid</div><div class="line">  <span class="keywordtype">character (len = *)</span>, <span class="keywordtype">intent(out)</span> :: name</div><div class="line">  <span class="keywordtype">integer</span> :: nf90_inq_compound_fieldname</div><div class="line"></div><div class="line"><span class="keyword">function </span>nf90_inq_compound_fieldindex(ncid, xtype, name, fieldid)</div><div class="line">  <span class="keywordtype">integer</span>, <span class="keywordtype">intent(in)</span> :: ncid</div><div class="line">  <span class="keywordtype">integer</span>, <span class="keywordtype">intent(in)</span> :: xtype</div><div class="line">  <span class="keywordtype">character (len = *)</span>, <span class="keywordtype">intent(in)</span> :: name</div><div class="line">  <span class="keywordtype">integer</span>, <span class="keywordtype">intent(out)</span> :: fieldid</div><div class="line">  <span class="keywordtype">integer</span> :: nf90_inq_compound_fieldindex</div><div class="line"></div><div class="line"><span class="keyword">function </span>nf90_inq_compound_fieldoffset(ncid, xtype, fieldid, offset)</div><div class="line">  <span class="keywordtype">integer</span>, <span class="keywordtype">intent(in)</span> :: ncid</div><div class="line">  <span class="keywordtype">integer</span>, <span class="keywordtype">intent(in)</span> :: xtype</div><div class="line">  <span class="keywordtype">integer</span>, <span class="keywordtype">intent(in)</span> :: fieldid</div><div class="line">  <span class="keywordtype">integer</span>, <span class="keywordtype">intent(out)</span> :: offset</div><div class="line">  <span class="keywordtype">integer</span> :: nf90_inq_compound_fieldoffset</div><div class="line"></div><div class="line"><span class="keyword">function </span>nf90_inq_compound_fieldtype(ncid, xtype, fieldid, field_typeid)</div><div class="line">  <span class="keywordtype">integer</span>, <span class="keywordtype">intent(in)</span> :: ncid</div><div class="line">  <span class="keywordtype">integer</span>, <span class="keywordtype">intent(in)</span> :: xtype</div><div class="line">  <span class="keywordtype">integer</span>, <span class="keywordtype">intent(in)</span> :: fieldid</div><div class="line">  <span class="keywordtype">integer</span>, <span class="keywordtype">intent(out)</span> :: field_typeid</div><div class="line">  <span class="keywordtype">integer</span> :: nf90_inq_compound_fieldtype</div><div class="line"></div><div class="line"><span class="keyword">function </span>nf90_inq_compound_fieldndims(ncid, xtype, fieldid, ndims)</div><div class="line">  <span class="keywordtype">integer</span>, <span class="keywordtype">intent(in)</span> :: ncid</div><div class="line">  <span class="keywordtype">integer</span>, <span class="keywordtype">intent(in)</span> :: xtype</div><div class="line">  <span class="keywordtype">integer</span>, <span class="keywordtype">intent(in)</span> :: fieldid</div><div class="line">  <span class="keywordtype">integer</span>, <span class="keywordtype">intent(out)</span> :: ndims</div><div class="line">  <span class="keywordtype">integer</span> :: nf90_inq_compound_fieldndims</div><div class="line"></div><div class="line"><span class="keyword">function </span>nf90_inq_cmp_fielddim_sizes(ncid, xtype, fieldid, dim_sizes)</div><div class="line">  <span class="keywordtype">integer</span>, <span class="keywordtype">intent(in)</span> :: ncid</div><div class="line">  <span class="keywordtype">integer</span>, <span class="keywordtype">intent(in)</span> :: xtype</div><div class="line">  <span class="keywordtype">integer</span>, <span class="keywordtype">intent(in)</span> :: fieldid</div><div class="line">  <span class="keywordtype">integer</span>, <span class="keywordtype">intent(out)</span> :: dim_sizes</div><div class="line">  <span class="keywordtype">integer</span> :: nf90_inq_cmp_fielddim_sizes</div></div><!-- fragment --><p><code>NCID</code></p>
<p>: The groupid where this compound type exists.</p>
<p><code>XTYPE</code></p>
<p>: The typeid for this compound type, as returned by NF90_DEF_COMPOUND, or NF90_INQ_VAR.</p>
<p><code>FIELDID</code></p>
<p>: A one-based index number specifying a field in the compound type.</p>
<p><code>NAME</code></p>
<p>: A character array which will get the name of the field. The name will be NF90_MAX_NAME characters, at most.</p>
<p><code>OFFSETP</code></p>
<p>: An integer which will get the offset of the field.</p>
<p><code>FIELD_TYPEID</code></p>
<p>: An integer which will get the typeid of the field.</p>
<p><code>NDIMSP</code></p>
<p>: An integer which will get the number of dimensions of the field.</p>
<p><code>DIM_SIZESP</code></p>
<p>: An integer array which will get the dimension sizes of the field.</p>
<h3>Errors</h3>
<p><code>NF90_NOERR</code></p>
<p>: No error.</p>
<p><code>NF90_EBADTYPEID</code></p>
<p>: Bad type id.</p>
<p><code>NF90_EHDFERR</code></p>
<p>: An error was reported by the HDF5 layer.</p>
<h3>Example</h3>
<h1><a class="anchor" id="f90-variable-length-array-introduction"></a>
5.7 Variable Length Array Introduction </h1>
<p>NetCDF-4 added support for a variable length array type. This is not supported in classic or 64-bit offset files, or in netCDF-4 files which were created with the NF90_CLASSIC_MODEL flag.</p>
<p>A variable length array is represented in C as a structure from HDF5, the nf90_vlen_t structure. It contains a len member, which contains the length of that array, and a pointer to the array.</p>
<p>So an array of VLEN in C is an array of nc_vlen_t structures. The only way to handle this in Fortran is with a character buffer sized correctly for the platform.</p>
<p>VLEN arrays are handled differently with respect to allocation of memory. Generally, when reading data, it is up to the user to malloc (and subsequently free) the memory needed to hold the data. It is up to the user to ensure that enough memory is allocated.</p>
<p>With VLENs, this is impossible. The user cannot know the size of an array of VLEN until after reading the array. Therefore when reading VLEN arrays, the netCDF library will allocate the memory for the data within each VLEN.</p>
<p>It is up to the user, however, to eventually free this memory. This is not just a matter of one call to free, with the pointer to the array of VLENs; each VLEN contains a pointer which must be freed.</p>
<p>Compression is permitted but may not be effective for VLEN data, because the compression is applied to the nc_vlen_t structures, rather than the actual data.</p>
<h2><a class="anchor" id="f90-define-a-variable-length-array-vlen-nf90_def_vlen"></a>
5.7.1 Define a Variable Length Array (VLEN): NF90_DEF_VLEN</h2>
<p>Use this function to define a variable length array type.</p>
<h3>Usage</h3>
<div class="fragment"><div class="line"><span class="keyword">function </span>nf90_def_vlen(ncid, name, base_typeid, xtypeid)</div><div class="line">  <span class="keywordtype">integer</span>, <span class="keywordtype">intent(in)</span> :: ncid</div><div class="line">  <span class="keywordtype">character (len = *)</span>, <span class="keywordtype">intent(in)</span> :: name</div><div class="line">  <span class="keywordtype">integer</span>, <span class="keywordtype">intent(in)</span> :: base_typeid</div><div class="line">  <span class="keywordtype">integer</span>, <span class="keywordtype">intent(out)</span> :: xtypeid</div><div class="line">  <span class="keywordtype">integer</span> :: nf90_def_vlen</div></div><!-- fragment --><p><code>NCID</code></p>
<p>: The ncid of the file to create the VLEN type in.</p>
<p><code>NAME</code></p>
<p>: A name for the VLEN type.</p>
<p><code>BASE_TYPEID</code></p>
<p>: The typeid of the base type of the VLEN. For example, for a VLEN of shorts, the base type is NF90_SHORT. This can be a user defined type.</p>
<p><code>XTYPEP</code></p>
<p>: The typeid of the new VLEN type will be set here.</p>
<h3>Errors</h3>
<p><code>NF90_NOERR</code></p>
<p>: No error.</p>
<p><code>NF90_EMAXNAME</code></p>
<p>: NF90_MAX_NAME exceeded.</p>
<p><code>NF90_ENAMEINUSE</code></p>
<p>: Name is already in use.</p>
<p><code>NF90_EBADNAME</code></p>
<p>: Attribute or variable name contains illegal characters.</p>
<p><code>NF90_EBADID</code></p>
<p>: ncid invalid.</p>
<p><code>NF90_EBADGRPID</code></p>
<p>: Group ID part of ncid was invalid.</p>
<p><code>NF90_EINVAL</code></p>
<p>: Size is invalid.</p>
<p><code>NF90_ENOMEM</code></p>
<p>: Out of memory.</p>
<h3>Example</h3>
<h2><a class="anchor" id="f90-learning-about-a-variable-length-array-vlen-type-nf90_inq_vlen"></a>
5.7.2 Learning about a Variable Length Array (VLEN) Type: NF90_INQ_VLEN</h2>
<p>Use this type to learn about a vlen.</p>
<h3>Usage</h3>
<div class="fragment"><div class="line"><span class="keyword">function </span>nf90_inq_vlen(ncid, xtype, name, datum_size, base_nc_type)</div><div class="line">  <span class="keywordtype">integer</span>, <span class="keywordtype">intent(in)</span> :: ncid</div><div class="line">  <span class="keywordtype">integer</span>, <span class="keywordtype">intent(in)</span> :: xtype</div><div class="line">  <span class="keywordtype">character (len = *)</span>, <span class="keywordtype">intent(out)</span> :: name</div><div class="line">  <span class="keywordtype">integer</span>, <span class="keywordtype">intent(out)</span> :: datum_size</div><div class="line">  <span class="keywordtype">integer</span>, <span class="keywordtype">intent(out)</span> :: base_nc_type</div><div class="line">  <span class="keywordtype">integer</span> :: nf90_inq_vlen</div></div><!-- fragment --><p><code>NCID</code></p>
<p>: The ncid of the file that contains the VLEN type.</p>
<p><code>XTYPE</code></p>
<p>: The type of the VLEN to inquire about.</p>
<p><code>NAME</code></p>
<p>: The name of the VLEN type. The name will be NF90_MAX_NAME characters or less.</p>
<p><code>DATUM_SIZEP</code></p>
<p>: A pointer to a size_t, this will get the size of one element of this vlen.</p>
<p><code>BASE_NF90_TYPEP</code></p>
<p>: An integer that will get the type of the VLEN base type. (In other words, what type is this a VLEN of?)</p>
<h4>Errors</h4>
<p><code>NF90_NOERR</code></p>
<p>: No error.</p>
<p><code>NF90_EBADTYPE</code></p>
<p>: Can’t find the typeid.</p>
<p><code>NF90_EBADID</code></p>
<p>: ncid invalid.</p>
<p><code>NF90_EBADGRPID</code></p>
<p>: Group ID part of ncid was invalid.</p>
<h3>Example</h3>
<h2><a class="anchor" id="f90-releasing-memory-for-a-variable-length-array-vlen-type-nf90_free_vlen"></a>
5.7.3 Releasing Memory for a Variable Length Array (VLEN) Type: NF90_FREE_VLEN</h2>
<p>When a VLEN is read into user memory from the file, the HDF5 library performs memory allocations for each of the variable length arrays contained within the VLEN structure. This memory must be freed by the user to avoid memory leaks.</p>
<p>This violates the normal netCDF expectation that the user is responsible for all memory allocation. But, with VLEN arrays, the underlying HDF5 library allocates the memory for the user, and the user is responsible for deallocating that memory.</p>
<h3>Usage</h3>
<div class="fragment"><div class="line"><span class="keyword">function </span>nf90_free_vlen(vl)</div><div class="line">  <span class="keywordtype">character (len = *)</span>, <span class="keywordtype">intent(in)</span> :: vlen</div><div class="line">  <span class="keywordtype">integer</span> :: nf90_free_vlen</div><div class="line"><span class="keyword">end function </span>nf90_free_vlen</div></div><!-- fragment --><p><code>VL</code></p>
<p>: The variable length array structure which is to be freed.</p>
<h3>Errors</h3>
<p><code>NF90_NOERR</code></p>
<p>: No error.</p>
<p><code>NF90_EBADTYPE</code></p>
<p>: Can’t find the typeid.</p>
<h3>Example</h3>
<h1><a class="anchor" id="f90-opaque-type-introduction"></a>
5.8 Opaque Type Introduction </h1>
<p>NetCDF-4 added support for the opaque type. This is not supported in classic or 64-bit offset files.</p>
<p>The opaque type is a type which is a collection of objects of a known size. (And each object is the same size). Nothing is known to netCDF about the contents of these blobs of data, except their size in bytes, and the name of the type.</p>
<p>To use an opaque type, first define it with <a href="#NF90_005fDEF_005fOPAQUE">Creating Opaque Types: NF90_DEF_OPAQUE</a>. If encountering an enum type in a new data file, use <a href="#NF90_005fINQ_005fOPAQUE">Learn About an Opaque Type: NF90_INQ_OPAQUE</a> to learn its name and size.</p>
<h2><a class="anchor" id="f90-creating-opaque-types-nf90_def_opaque"></a>
5.8.1 Creating Opaque Types: NF90_DEF_OPAQUE</h2>
<p>Create an opaque type. Provide a size and a name.</p>
<h3>Usage</h3>
<div class="fragment"><div class="line"><span class="keyword">function </span>nf90_def_opaque(ncid, size, name, xtype)</div><div class="line">  <span class="keywordtype">integer</span>, <span class="keywordtype">intent(in)</span> :: ncid</div><div class="line">  <span class="keywordtype">integer</span>, <span class="keywordtype">intent(in)</span> :: size</div><div class="line">  <span class="keywordtype">character (len = *)</span>, <span class="keywordtype">intent(in)</span> :: name</div><div class="line">  <span class="keywordtype">integer</span>, <span class="keywordtype">intent(out)</span> :: xtype</div><div class="line">  <span class="keywordtype">integer</span> :: nf90_def_opaque</div></div><!-- fragment --><p><code>NCID</code></p>
<p>: The groupid where the type will be created. The type may be used anywhere in the file, no matter what group it is in.</p>
<p><code>NAME</code></p>
<p>: The name for this type. Must be shorter than NF90_MAX_NAME.</p>
<p><code>SIZE</code></p>
<p>: The size of each opaque object.</p>
<p><code>TYPEIDP</code></p>
<p>: Pointer where the new typeid for this type is returned. Use this typeid when defining variables of this type with <a href="#NF90_005fDEF_005fVAR">Create a Variable: <code>NF90_DEF_VAR</code></a>.</p>
<h3>Errors</h3>
<p><code>NF90_NOERR</code></p>
<p>: No error.</p>
<p><code>NF90_EBADTYPEID</code></p>
<p>: Bad typeid.</p>
<p><code>NF90_EBADFIELDID</code></p>
<p>: Bad fieldid.</p>
<p><code>NF90_EHDFERR</code></p>
<p>: An error was reported by the HDF5 layer.</p>
<h3>Example</h3>
<h2><a class="anchor" id="f90-learn-about-an-opaque-type-nf90_inq_opaque"></a>
5.8.2 Learn About an Opaque Type: NF90_INQ_OPAQUE</h2>
<p>Given a typeid, get the information about an opaque type.</p>
<h3>Usage</h3>
<div class="fragment"><div class="line"><span class="keyword">function </span>nf90_inq_opaque(ncid, xtype, name, size)</div><div class="line">  <span class="keywordtype">integer</span>, <span class="keywordtype">intent(in)</span> :: ncid</div><div class="line">  <span class="keywordtype">integer</span>, <span class="keywordtype">intent(in)</span> :: xtype</div><div class="line">  <span class="keywordtype">character (len = *)</span>, <span class="keywordtype">intent(out)</span> :: name</div><div class="line">  <span class="keywordtype">integer</span>, <span class="keywordtype">intent(out)</span> :: size</div><div class="line">  <span class="keywordtype">integer</span> :: nf90_inq_opaque</div></div><!-- fragment --><p><code>NCID</code></p>
<p>: The ncid for the group containing the opaque type.</p>
<p><code>XTYPE</code></p>
<p>: The typeid for this opaque type, as returned by NF90_DEF_COMPOUND, or NF90_INQ_VAR.</p>
<p><code>NAME</code></p>
<p>: The name of the opaque type will be copied here. It will be NF90_MAX_NAME bytes or less.</p>
<p><code>SIZEP</code></p>
<p>: The size of the opaque type will be copied here.</p>
<h3>Errors</h3>
<p><code>NF90_NOERR</code></p>
<p>: No error.</p>
<p><code>NF90_EBADTYPEID</code></p>
<p>: Bad typeid.</p>
<p><code>NF90_EBADFIELDID</code></p>
<p>: Bad fieldid.</p>
<p><code>NF90_EHDFERR</code></p>
<p>: An error was reported by the HDF5 layer.</p>
<h3>Example</h3>
<h1><a class="anchor" id="f90-enum-type-introduction"></a>
5.9 Enum Type Introduction </h1>
<p>NetCDF-4 added support for the enum type. This is not supported in classic or 64-bit offset files.</p>
<h2><a class="anchor" id="f90-creating-a-enum-type-nf90_def_enum"></a>
5.9.1 Creating a Enum Type: NF90_DEF_ENUM</h2>
<p>Create an enum type. Provide an ncid, a name, and a base integer type.</p>
<p>After calling this function, fill out the type with repeated calls to NF90_INSERT_ENUM (see section <a href="#NF90_005fINSERT_005fENUM">Inserting a Field into a Enum Type: NF90_INSERT_ENUM</a>). Call NF90_INSERT_ENUM once for each value you wish to make part of the enumeration.</p>
<h3>Usage</h3>
<div class="fragment"><div class="line"><span class="keyword">function </span>nf90_def_enum(ncid, base_typeid, name, typeid)</div><div class="line">  <span class="keywordtype">integer</span>, <span class="keywordtype">intent(in)</span> :: ncid</div><div class="line">  <span class="keywordtype">integer</span>, <span class="keywordtype">intent(in)</span> :: base_typeid</div><div class="line">  <span class="keywordtype">character (len = *)</span>, <span class="keywordtype">intent(in)</span> :: name</div><div class="line">  <span class="keywordtype">integer</span>, <span class="keywordtype">intent(out)</span> :: typeid</div><div class="line">  <span class="keywordtype">integer</span> :: nf90_def_enum</div></div><!-- fragment --><p><code>NCID</code></p>
<p>: The groupid where this compound type will be created.</p>
<p><code>BASE_TYPEID</code></p>
<p>: The base integer type for this enum. Must be one of: NF90_BYTE, NF90_UBYTE, NF90_SHORT, NF90_USHORT, NF90_INT, NF90_UINT, NF90_INT64, NF90_UINT64.</p>
<p><code>NAME</code></p>
<p>: The name of the new enum type.</p>
<p><code>TYPEIDP</code></p>
<p>: The typeid of the new type will be placed here.</p>
<h3>Errors</h3>
<p><code>NF90_NOERR</code></p>
<p>: No error.</p>
<p><code>NF90_EBADID</code></p>
<p>: Bad group id.</p>
<p><code>NF90_ENAMEINUSE</code></p>
<p>: That name is in use. Compound type names must be unique in the data file.</p>
<p><code>NF90_EMAXNAME</code></p>
<p>: Name exceeds max length NF90_MAX_NAME.</p>
<p><code>NF90_EBADNAME</code></p>
<p>: Name contains illegal characters.</p>
<p><code>NF90_ENOTNC4</code></p>
<p>: Attempting a netCDF-4 operation on a netCDF-3 file. NetCDF-4 operations can only be performed on files defined with a create mode which includes flag NF90_NETCDF4. (see section <a href="#NF90_005fOPEN">NF90_OPEN</a>).</p>
<p><code>NF90_ESTRICTNC3</code></p>
<p>: This file was created with the strict netcdf-3 flag, therefore netcdf-4 operations are not allowed. (see section <a href="#NF90_005fOPEN">NF90_OPEN</a>).</p>
<p><code>NF90_EHDFERR</code></p>
<p>: An error was reported by the HDF5 layer.</p>
<p><code>NF90_EPERM</code></p>
<p>: Attempt to write to a read-only file.</p>
<p><code>NF90_ENOTINDEFINE</code></p>
<p>: Not in define mode.</p>
<h3>Example</h3>
<h2><a class="anchor" id="f90-inserting-a-field-into-a-enum-type-nf90_insert_enum"></a>
5.9.2 Inserting a Field into a Enum Type: NF90_INSERT_ENUM</h2>
<p>Insert a named member into a enum type.</p>
<h3>Usage</h3>
<div class="fragment"><div class="line"><span class="keyword">function </span>nf90_insert_enum(ncid, xtype, name, value)</div><div class="line">  <span class="keywordtype">integer</span>, <span class="keywordtype">intent(in)</span> :: ncid</div><div class="line">  <span class="keywordtype">integer</span>, <span class="keywordtype">intent(in)</span> :: xtype</div><div class="line">  <span class="keywordtype">character (len = *)</span>, <span class="keywordtype">intent(in)</span> :: name</div><div class="line">  <span class="keywordtype">integer</span>, <span class="keywordtype">intent(in)</span> :: value</div><div class="line">  <span class="keywordtype">integer</span> :: nf90_insert_enum</div></div><!-- fragment --><p><code>NCID</code></p>
<p>: The ncid of the group which contains the type.</p>
<p><code>TYPEID</code></p>
<p>: The typeid for this enum type, as returned by nf90_def_enum, or nf90_inq_var.</p>
<p><code>IDENTIFIER</code></p>
<p>: The identifier of the new member.</p>
<p><code>VALUE</code></p>
<p>: The value that is to be associated with this member.</p>
<h3>Errors</h3>
<p><code>NF90_NOERR</code></p>
<p>: No error.</p>
<p><code>NF90_EBADID</code></p>
<p>: Bad group id.</p>
<p><code>NF90_ENAMEINUSE</code></p>
<p>: That name is in use. Field names must be unique within a enum type.</p>
<p><code>NF90_EMAXNAME</code></p>
<p>: Name exceed max length NF90_MAX_NAME.</p>
<p><code>NF90_EBADNAME</code></p>
<p>: Name contains illegal characters.</p>
<p><code>NF90_ENOTNC4</code></p>
<p>: Attempting a netCDF-4 operation on a netCDF-3 file. NetCDF-4 operations can only be performed on files defined with a create mode which includes flag NF90_NETCDF4. (see section <a href="#NF90_005fOPEN">NF90_OPEN</a>).</p>
<p><code>NF90_ESTRICTNC3</code></p>
<p>: This file was created with the strict netcdf-3 flag, therefore netcdf-4 operations are not allowed. (see section <a href="#NF90_005fOPEN">NF90_OPEN</a>).</p>
<p><code>NF90_EHDFERR</code></p>
<p>: An error was reported by the HDF5 layer.</p>
<p><code>NF90_ENOTINDEFINE</code></p>
<p>: Not in define mode.</p>
<h3>Example</h3>
<h2><a class="anchor" id="f90-learn-about-a-enum-type-nf90_inq_enum"></a>
5.9.3 Learn About a Enum Type: NF90_INQ_ENUM</h2>
<p>Get information about a user-defined enumeration type.</p>
<h3>Usage</h3>
<div class="fragment"><div class="line"><span class="keyword">function </span>nf90_inq_enum(ncid, xtype, name, base_nc_type, base_size, num_members)</div><div class="line">  <span class="keywordtype">integer</span>, <span class="keywordtype">intent(in)</span> :: ncid</div><div class="line">  <span class="keywordtype">integer</span>, <span class="keywordtype">intent(in)</span> :: xtype</div><div class="line">  <span class="keywordtype">character (len = *)</span>, <span class="keywordtype">intent(out)</span> :: name</div><div class="line">  <span class="keywordtype">integer</span>, <span class="keywordtype">intent(out)</span> :: base_nc_type</div><div class="line">  <span class="keywordtype">integer</span>, <span class="keywordtype">intent(out)</span> :: base_size</div><div class="line">  <span class="keywordtype">integer</span>, <span class="keywordtype">intent(out)</span> :: num_members</div><div class="line">  <span class="keywordtype">integer</span> :: nf90_inq_enum</div></div><!-- fragment --><p><code>NCID</code></p>
<p>: The group ID of the group which holds the enum type.</p>
<p><code>XTYPE</code></p>
<p>: The typeid for this enum type, as returned by NF90_DEF_ENUM, or NF90_INQ_VAR.</p>
<p><code>NAME</code></p>
<p>: Character array which will get the name. It will have a maximum length of NF90_MAX_NAME.</p>
<p><code>BASE_NF90_TYPE</code></p>
<p>: An integer which will get the base integer type of this enum.</p>
<p><code>BASE_SIZE</code></p>
<p>: An integer which will get the size (in bytes) of the base integer type of this enum.</p>
<p><code>NUM_MEMBERS</code></p>
<p>: An integer which will get the number of members defined for this enumeration type.</p>
<h3>Errors</h3>
<p><code>NF90_NOERR</code></p>
<p>: No error.</p>
<p><code>NF90_EBADTYPEID</code></p>
<p>: Bad type id.</p>
<p><code>NF90_EHDFERR</code></p>
<p>: An error was reported by the HDF5 layer.</p>
<h3>Example</h3>
<h2><a class="anchor" id="f90-learn-the-name-of-a-enum-type-nf90_inq_enum_member"></a>
5.9.4 Learn the Name of a Enum Type: nf90_inq_enum_member</h2>
<p>Get information about a member of an enum type.</p>
<h3>Usage</h3>
<div class="fragment"><div class="line"><span class="keyword">function </span>nf90_inq_enum_member(ncid, xtype, idx, name, value)</div><div class="line">  <span class="keywordtype">integer</span>, <span class="keywordtype">intent(in)</span> :: ncid</div><div class="line">  <span class="keywordtype">integer</span>, <span class="keywordtype">intent(in)</span> :: xtype</div><div class="line">  <span class="keywordtype">integer</span>, <span class="keywordtype">intent(in)</span> :: idx</div><div class="line">  <span class="keywordtype">character (len = *)</span>, <span class="keywordtype">intent(out)</span> :: name</div><div class="line">  <span class="keywordtype">integer</span>, <span class="keywordtype">intent(in)</span> :: value</div><div class="line">  <span class="keywordtype">integer</span> :: nf90_inq_enum_member</div></div><!-- fragment --><p><code>NCID</code></p>
<p>: The groupid where this enum type exists.</p>
<p><code>XTYPE</code></p>
<p>: The typeid for this enum type.</p>
<p><code>IDX</code></p>
<p>: The one-based index number for the member of interest.</p>
<p><code>NAME</code></p>
<p>: A character array which will get the name of the member. It will have a maximum length of NF90_MAX_NAME.</p>
<p><code>VALUE</code></p>
<p>: An integer that will get the value associated with this member.</p>
<h3>Errors</h3>
<p><code>NF90_NOERR</code></p>
<p>: No error.</p>
<p><code>NF90_EBADTYPEID</code></p>
<p>: Bad type id.</p>
<p><code>NF90_EHDFERR</code></p>
<p>: An error was reported by the HDF5 layer.</p>
<h3>Example</h3>
<h2><a class="anchor" id="f90-learn-the-name-of-a-enum-type-nf90_inq_enum_ident"></a>
5.9.5 Learn the Name of a Enum Type: NF90_INQ_ENUM_IDENT</h2>
<p>Get the name which is associated with an enum member value.</p>
<p>This is similar to NF90_INQ_ENUM_MEMBER, but instead of using the index of the member, you use the value of the member.</p>
<h3>Usage</h3>
<div class="fragment"><div class="line"><span class="keyword">function </span>nf90_inq_enum_ident(ncid, xtype, value, idx)</div><div class="line">  <span class="keywordtype">integer</span>, <span class="keywordtype">intent(in)</span> :: ncid</div><div class="line">  <span class="keywordtype">integer</span>, <span class="keywordtype">intent(in)</span> :: xtype</div><div class="line">  <span class="keywordtype">integer</span>, <span class="keywordtype">intent(in)</span> :: value</div><div class="line">  <span class="keywordtype">integer</span>, <span class="keywordtype">intent(out)</span> :: idx</div><div class="line">  <span class="keywordtype">integer</span> :: nf90_inq_enum_ident</div></div><!-- fragment --><p><code>NCID</code></p>
<p>: The groupid where this enum type exists.</p>
<p><code>XTYPE</code></p>
<p>: The typeid for this enum type.</p>
<p><code>VALUE</code></p>
<p>: The value for which an identifier is sought.</p>
<p><code>IDENTIFIER</code></p>
<p>: A character array that will get the identifier. It will have a maximum length of NF90_MAX_NAME.</p>
<h3>Return Code</h3>
<p><code>NF90_NOERR</code></p>
<p>: No error.</p>
<p><code>NF90_EBADTYPEID</code></p>
<p>: Bad type id, or not an enum type.</p>
<p><code>NF90_EHDFERR</code></p>
<p>: An error was reported by the HDF5 layer.</p>
<p><code>NF90_EINVAL</code></p>
<p>: The value was not found in the enum.</p>
<h3>Example</h3>
</div></div><!-- contents -->
</div><!-- doc-content -->

<hr size="2"/>
<address style="text-align: center;">
<a href="http://www.unidata.ucar.edu/software/netcdf/">Return to the Main Unidata NetCDF page.</a><br>
<img src="http://www.unidata.ucar.edu/images/logos/uniLogo.png">
<address style="text-align: right;"><small>
Generated on Wed Jan 17 2018 10:01:47 for NetCDF-Fortran. NetCDF is
a <a href="http://www.unidata.ucar.edu/">Unidata</a> library.</small></address>
</body>
</html>
